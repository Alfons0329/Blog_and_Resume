{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to alfons0329's Blog\n\n\n\n\n\n\nAbout Me\n\n\n\n\nUndergraduate student major in Dept. of Computer Science at National Chaio Tung University Taiwan\n\n\nStarted to learn programming in Oct. 2015\n\n\nTime stamp of learning programming language\n\n\n\n\nOct. 2015 C in Intro to Computer Science and Programming\n\nFeb. 2016 C++ in Object-Oriented programming \nGitHub repository of this course\n\nMar. 2016 Verilog in Digital Circuit Lab \nGitHub repository of this course\n\nJun. 2017 JavaScript, processing simple HTML and CSS in my own website practice\nGitHub repository of this course\n\nSep. 2017 Python in Intro to Machine Learning \nGitHub repository of this course\n\nSep. 2017 ARM Assembly in Microprocessor Lab \nGitHub repository of this course\n\n\n\n\nFavorite extracurricular activities\n\n\nLanguage abilities\n\n\n\n\nTOEIC 925 and TOEFL iBT102(26/28/23/25) both on First try \n\nWant to try on Japanese JLPT N3(Intermediate level) on Jul. 2018\n\n\nMy GitHub personal page\n\n\nCheck here",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-alfons0329s-blog",
            "text": "",
            "title": "Welcome to alfons0329's Blog"
        },
        {
            "location": "/#about-me",
            "text": "Undergraduate student major in Dept. of Computer Science at National Chaio Tung University Taiwan  Started to learn programming in Oct. 2015  Time stamp of learning programming language   Oct. 2015 C in Intro to Computer Science and Programming \nFeb. 2016 C++ in Object-Oriented programming  GitHub repository of this course \nMar. 2016 Verilog in Digital Circuit Lab  GitHub repository of this course \nJun. 2017 JavaScript, processing simple HTML and CSS in my own website practice GitHub repository of this course \nSep. 2017 Python in Intro to Machine Learning  GitHub repository of this course \nSep. 2017 ARM Assembly in Microprocessor Lab  GitHub repository of this course   Favorite extracurricular activities  Language abilities   TOEIC 925 and TOEFL iBT102(26/28/23/25) both on First try  \nWant to try on Japanese JLPT N3(Intermediate level) on Jul. 2018",
            "title": "About Me"
        },
        {
            "location": "/#my-github-personal-page",
            "text": "Check here",
            "title": "My GitHub personal page"
        },
        {
            "location": "/univ_notes/intro_ml/intro_ml/",
            "text": "",
            "title": "Junior 1st sem. Intro. to Machine Learning"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/",
            "text": "Microprocessor Lab\n\n\nFall 2017\n\nLecturer: \nS.L. Tsao\n in CS@NCTU \n\nTime: 5EF @EDB27_NCTU 3IJK @EC222_NCTU\n\n\nMicroprocessor Lab Final Project\n\n\n\n\n\n\nCourse Introduction \n\nThis course mainly focus on the embedded system understanding, and we use the ARM microarchitecture in this semester.\n\n\n\n\n\n\nGoal of this course \n\nTo briefly understand the ARM Assembly, how to write C code in the embedded developing board and make a small project from it by your own.\n\n\n\n\n\n\nEmbedded board spec:\n\n1.Nucleo STM32L476RG ARM Microarchitecture \n\n2.Built-in 400MHz CPU (customizable frequency with internal clock settings provided) \n\n3.GPIO Available \n\n\nDetailed specs\n \n\n\n\n\n\n\nIDE for this course\n\nEclipse  AC6 System Workbench for STM32 where JRE7 is required in your system\n\n\n\n\n\n\n1.Download from \nHere for Linux version\n\n\n\n\nLab project and final project \n\nThere are 10 labs in this semester on a weekly basis, the first five focus on basic operation of ARM Assembly, namely the lab assignments are\ntypically written in the ARM Assembly, while the last five labs are written in C language, but a embedded-like C language.\n\n\n\n\nAbout my final project\n\n\n\n\nProject name: The RGB Ambient light. \n\n\nFeatures: \n\n1.Fully-customizable RGB proportion control. \n\n2.Color cycle speed controller (faster->original)\n\n3.Light-sensitive resistor ADC ,detecting the background light for light quantity settings\n\n\nGitHub repo for this final project\n\n\nProject demo video\n\n\n\n\nPart0. Origin of this idea and preparation\n\n\n\n\n\n\nOrigin of this idea \n\nI once have the fully-customizable dynamic RGB LED backlit keyboard \nSteelSeries APEXM 650\n \n On account of having not much time in the end of semester(machine learning final project + compiler design final project.)\nMy \nteammate\n and I decided to do it.\n\n\n\n\n\n\nPreparation of materials and tools for this project \n\n1.A STM32L476RG Embedded board\n\n2.Breadboard\n\n3.4pin RGB LED*5 \nClick here\n\n4.R1000 Resistor\n\n5.Some Dupont cables\n\n\n\n\n\n\nPart1. Circuit connection\n\n\n1.Parallel connection of 5 RGB LEDs on the breadboard.\n\n2.Connect separately to the GPIO pin on the STM32 providing the capability of PWM output.\n\n3.Connect the keypad to the STM32.\n\n4.Connect the light-sensitive resistor to GPIO with capability of ADC(Analog-Digital Converter).\n\n5.The GPIO Connection is like.\n\n6.Overall GPIO port configuration.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nGPIOB\n->\nASCR\n \n|=\n \n0\nb1\n;\n \n//turn on the analog controller in PB0\n\n\n\nvoid\n \nkeypad_init\n()\n//keypad along with GPIO Init together\n\n\n{\n\n\n    \nRCC\n->\nAHB2ENR\n   \n|=\n \n0\nb00000000000000000000000000000111\n;\n \n//open port A,B,C\n\n                      \n//10987654321098765432109876543210\n\n    \nGPIOC\n->\nMODER\n   \n&=\n \n0\nb11111111111111111111111100000000\n;\n \n//pc 3 2 1 0 as input of keypad\n\n    \nGPIOC\n->\nMODER\n   \n|=\n \n0\nb00000000000000000000000001010101\n;\n\n    \nGPIOC\n->\nPUPDR\n   \n&=\n \n0\nb11111111111111111111111100000000\n;\n\n    \nGPIOC\n->\nPUPDR\n   \n|=\n \n0\nb00000000000000000000000001010101\n;\n\n    \nGPIOC\n->\nOSPEEDR\n \n&=\n \n0\nb11111111111111111111111100000000\n;\n\n    \nGPIOC\n->\nOSPEEDR\n \n|=\n \n0\nb00000000000000000000000001010101\n;\n\n    \nGPIOC\n->\nODR\n     \n|=\n \n0\nb00000000000000000000000000001111\n;\n\n                      \n//10987654321098765432109876543210\n\n    \nGPIOB\n->\nMODER\n   \n&=\n \n0\nb11111111111111110000000011111111\n;\n \n//pb 7 6 5 4 as output of keypad\n\n    \nGPIOB\n->\nPUPDR\n   \n&=\n \n0\nb11111111111111110000000011111111\n;\n\n    \nGPIOB\n->\nPUPDR\n   \n|=\n \n0\nb00000000000000001010101000000000\n;\n\n\n\n\n}\n\n\n\nvoid\n \nGPIO_init_AF\n()\n \n//GPIO Alternate Function Init\n\n\n{\n\n    \n/***************pin and alternate function***************\n\n\n     * PB3 + AF1 which is corresponding to TIM2_CH2 RED\n\n\n     * PA1 + AF2 which is corresponding to TIM5_CH2 GREEN\n\n\n     * PA6 + AF2 which is corresponding to TIM3_CH1 BLUE\n\n\n     ********************************************************/\n\n                       \n//10987654321098765432109876543210\n\n    \nGPIOA\n->\nMODER\n    \n&=\n \n0\nb11111111111111111100111111110011\n;\n\n    \nGPIOA\n->\nMODER\n    \n|=\n \n0\nb00000000000000000010000000001000\n;\n\n    \n//PortA Pin        //10987654321098765432109876543210\n\n    \nGPIOA\n->\nAFR\n[\n0\n]\n   \n=\n  \n0\nb00000010000100000000000000100000\n;\n\n\n    \n//PB3 TIM2_CH2\n\n    \nGPIOB\n->\nAFR\n[\n0\n]\n   \n&=\n \n~\nGPIO_AFRL_AFSEL3\n;\n//AFR[0] LOW\n\n    \nGPIOB\n->\nAFR\n[\n0\n]\n   \n|=\n \n(\n0\nb0001\n<<\nGPIO_AFRL_AFSEL3_Pos\n);\n//PB3 Alternate function mode\n\n\n}\n\n\n\n\n\n\n\nPart2. Key idea of this project\n\n\nThe PWM(Pulse Width Modulation) \nWiki\n\nPWM cycle (HV/ALL) = The proportion where light lights, the longer HV lasts, the brighter of the certain part of RGB(either one) will do.\n\nThe Pulse Width can be used to simulate the analog output like this.\n\n\nPWM Video\n\nThe same is true of other 3 colors, configuring with the following code and expanations.\n\n* Basic logic for this project \n\nInitialize system -> PWM and timer configuration -> Presskey -> Color changing scheme along with ADC light intensity detection for power saving.\n\n\n1\n2\n3\n4\nint\n \nkeypad_value\n[\n4\n][\n4\n]\n \n=\n \n{{\n0\n,\n1\n,\n2\n,\n3\n},\n\n                          \n{\n4\n,\n5\n,\n6\n,\n7\n},\n\n                          \n{\n8\n,\n9\n,\n10\n,\n11\n},\n\n                          \n{\n12\n,\n13\n,\n14\n,\n15\n}};\n\n\n\n\n\n\n\nkeypad explanation \n\n0 red+\n\n1 green+\n\n2 blue+\n\n3 cycle_speed+\n\n4 red-\n\n5 green-\n\n6 blue-\n\n7 customize mode(0 1 2 4 5 6 applicable)\n\n8 only red\n\n9 only green\n\n10 only blue\n\n11 light ADC mode\n\n12 red+greren\n\n13 green+blue\n\n14 red+blue\n\n15 off system, remember the last state, s.t. user configuration is not lost after shut down\n\n* Setup the PWM channel\n\nRefer to \nthis pdf\n for PWM channel-GPIO port configuration, each port has its corresponding PWM channel and built-in system clock, be sure to make it right! \n\n\nMore understanding and details are written in comments of the following source code.\n\nPlease refer to \np.1006-1039\n of \nthis pdf\n to see how to config the PWM cycle with certain registers in timer.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\nvoid\n \nTimer_init\n()\n \n//Use 3\n\n\n{\n\n    \n// PA3 + AF1 which is corresponding to TIM2_CH1\n\n    \n// PA1 + AF2 which is corresponding to TIM5_CH2\n\n    \n// PA6 + AF2 which is corresponding to TIM3_CH1\n\n    \nRCC\n->\nAPB1ENR1\n \n|=\n \nRCC_APB1ENR1_TIM2EN\n;\n\n    \nRCC\n->\nAPB1ENR1\n \n|=\n \nRCC_APB1ENR1_TIM3EN\n;\n\n    \nRCC\n->\nAPB1ENR1\n \n|=\n \nRCC_APB1ENR1_TIM5EN\n;\n\n\n    \n//setting for timer 2\n\n    \nTIM2\n->\nCR1\n \n&=\n \n0x0000\n;\n \n//p1027 Turned on the counter as the count up mode\n\n    \nTIM2\n->\nARR\n \n=\n \n(\nuint32_t\n)\nSECOND_SLICE\n;\n//Reload value\n\n    \nTIM2\n->\nPSC\n \n=\n \n(\nuint32_t\n)\nCOUNT_UP\n;\n//Prescaler\n\n    \nTIM2\n->\nEGR\n \n=\n \nTIM_EGR_UG\n;\n     \n//update the counter again p1035\n\n\n    \n//setting for timer 3\n\n    \nTIM3\n->\nCR1\n \n&=\n \n0x0000\n;\n \n//p1027 Turned on the counter as the count up mode\n\n    \nTIM3\n->\nARR\n \n=\n \n(\nuint32_t\n)\nSECOND_SLICE\n;\n//Reload value\n\n    \nTIM3\n->\nPSC\n \n=\n \n(\nuint32_t\n)\nCOUNT_UP\n;\n//Prescaler\n\n    \nTIM3\n->\nEGR\n \n=\n \nTIM_EGR_UG\n;\n//Reinitialize the counter\n\n\n    \n//setting for timer 5\n\n    \nTIM5\n->\nCR1\n \n&=\n \n0x0000\n;\n \n//p1027 Turned on the counter as the count up mode\n\n    \nTIM5\n->\nARR\n \n=\n \n(\nuint32_t\n)\nSECOND_SLICE\n;\n//Reload value\n\n    \nTIM5\n->\nPSC\n \n=\n \n(\nuint32_t\n)\nCOUNT_UP\n;\n//Prescaler\n\n    \nTIM5\n->\nEGR\n \n=\n \nTIM_EGR_UG\n;\n//Reinitialize the counter\n\n\n}\n\n\n\n\nvoid\n \nPWM_channel_init\n()\n\n\n{\n\n    \n/***********************setting for the TIM2_CH2 RED**************************/\n\n    \n// PB3 + AF1 which is corresponding to TIM2_CH2 RED\n\n    \n//Output compare 2 mode\n\n    \nTIM2\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC2M\n;\n\n    \n//110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive\n\n    \nTIM2\n->\nCCMR1\n \n|=\n \n(\n0\nb0110\n \n<<\n \nTIM_CCMR1_OC2M_Pos\n);\n\n\n    \n//Output Compare 2 Preload Enable\n\n    \nTIM2\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC2PE\n;\n//OCxPE\n\n    \n//1: enable TIMx_CCR1 Preload\n\n    \nTIM2\n->\nCCMR1\n \n|=\n \n(\n0\nb1\n \n<<\n \nTIM_CCMR1_OC2PE_Pos\n);\n\n    \n//enable auto reload pre-load\n\n    \nTIM2\n->\nCR1\n \n|=\n \nTIM_CR1_ARPE\n;\n\n\n    \n//duty cycle initial 50 (CCR2/ARR)\n\n    \n//TIM2->CCR2 = duty_cycle_R;\n\n    \n//enable output compare\n\n    \nTIM2\n->\nCCER\n \n|=\n \nTIM_CCER_CC2E\n;\n\n\n    \n/***********************setting for the TIM5_CH2 GREEN**************************/\n\n    \n// PA1 + AF2 which is corresponding to TIM5_CH2 GREEN\n\n    \n//Output compare 2 mode\n\n    \nTIM5\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC2M\n;\n\n    \n//110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive\n\n    \nTIM5\n->\nCCMR1\n \n|=\n \n(\n0\nb0110\n \n<<\n \nTIM_CCMR1_OC2M_Pos\n);\n\n\n    \n//Output Compare 2 Preload Enable\n\n    \nTIM5\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC2PE\n;\n//OCxPE\n\n    \n//1: enable TIMx_CCR1 Preload\n\n    \nTIM5\n->\nCCMR1\n \n|=\n \n(\n0\nb1\n \n<<\n \nTIM_CCMR1_OC2PE_Pos\n);\n\n    \n//enable auto reload pre-load\n\n    \nTIM5\n->\nCR1\n \n|=\n \nTIM_CR1_ARPE\n;\n\n\n    \n//duty cycle initial 50 (CCR2/ARR)\n\n    \n//TIM5->CCR2 = duty_cycle_G;\n\n    \n//enable output compare\n\n    \nTIM5\n->\nCCER\n \n|=\n \nTIM_CCER_CC2E\n;\n\n\n    \n/***********************setting for the TIM3_CH1 BLUE**************************/\n\n    \n// PA6 + AF2 which is corresponding to TIM3_CH1 BLUE\n\n    \n//Output compare 2 mode\n\n    \nTIM3\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC1M\n;\n\n    \n//110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive\n\n    \nTIM3\n->\nCCMR1\n \n|=\n \n(\n0\nb0110\n \n<<\n \nTIM_CCMR1_OC1M_Pos\n);\n\n\n    \n//Output Compare 2 Preload Enable\n\n    \nTIM3\n->\nCCMR1\n \n&=\n \n~\nTIM_CCMR1_OC1PE\n;\n//OCxPE\n\n    \n//1: enable TIMx_CCR1 Preload\n\n    \nTIM3\n->\nCCMR1\n \n|=\n \n(\n0\nb1\n \n<<\n \nTIM_CCMR1_OC1PE_Pos\n);\n\n    \n//enable auto reload pre-load\n\n    \nTIM3\n->\nCR1\n \n|=\n \nTIM_CR1_ARPE\n;\n\n\n    \n//duty cycle initial 50 (CCR2/ARR)\n\n    \n//TIM3->CCR1 = duty_cycle_B;\n\n    \n//enable output compare\n\n    \nTIM3\n->\nCCER\n \n|=\n \nTIM_CCER_CC1E\n;\n\n\n\n}\n\n\n\n\n\n\n\n*\n\n\nPart3. It's time to change the color.\n\n\n\n\nInitialize to different duty cycle. \n\nEach color has its own PWM cycle, by setting the PWM cycle differently, we will be able to interleave 3 colors\nand mixing them together since there pulse waves have \"time shifting (or say phase shifting)\" to each other. \n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n#define RED_START 10\n\n\n#define GREEN_START 91\n\n\n#define BLUE_START 172\n\n\n\nduty_cycle_R\n \n=\n \nRED_START\n;\n\n\nduty_cycle_G\n \n=\n \nGREEN_START\n;\n\n\nduty_cycle_B\n \n=\n \nBLUE_START\n;\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \n//use the time delay mode to make the interleaving and the color changing scheme\n\n    \nfpu_enable\n();\n\n    \nkeypad_init\n();\n\n    \nGPIO_init_AF\n();\n\n    \nTimer_init\n();\n\n    \nconfigureADC\n();\n\n    \nstartADC\n();\n\n    \nduty_cycle_R\n \n=\n \nRED_START\n;\n\n    \nduty_cycle_G\n \n=\n \nGREEN_START\n;\n\n    \nduty_cycle_B\n \n=\n \nBLUE_START\n;\n\n    \ncur_state\n \n=\n \nCYCLE_MODE\n;\n\n    \nwhile\n(\n1\n)\n\n    \n{\n\n        \nPWM_channel_init\n();\n\n        \nchromatic_scheme\n(\nkeypad_scan\n());\n\n    \n}\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\n\n\nIncrease, decrease and cycle. \n\nstate_color is the state indicating whether to increase the pulse cycle or decrease, with an view to simulating the sin-wave-like phase wave. \n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nvoid\n \ncycle_mode\n(\nint\n \ndelay_time\n){\n\n    \nPWM_channel_init\n();\n\n    \nif\n \n(\nstate_R\n){\n\n        \nif\n \n(\nduty_cycle_R\n \n>\n \nSECOND_SLICE\n){\n\n            \nstate_R\n \n=\n \n0\n;\n\n        \n}\n \nelse\n \n{\n\n            \nduty_cycle_R\n \n+=\n \n20\n;\n\n        \n}\n\n    \n}\n \nelse\n \n{\n\n        \nif\n \n(\nduty_cycle_R\n \n<\n \n20\n){\n\n            \nstate_R\n \n=\n \n1\n;\n\n        \n}\n \nelse\n \n{\n\n            \nduty_cycle_R\n \n-=\n \n20\n;\n\n        \n}\n\n    \n}\n\n\n    \nif\n \n(\nstate_G\n){\n\n        \nif\n \n(\nduty_cycle_G\n \n>\n \nSECOND_SLICE\n){\n\n            \nstate_G\n \n=\n \n0\n;\n\n    \n}\n \nelse\n \n{\n\n        \nduty_cycle_G\n \n+=\n \n40\n;\n\n        \n}\n\n    \n}\n \nelse\n \n{\n\n        \nif\n \n(\nduty_cycle_G\n \n<\n \n40\n){\n\n            \nstate_G\n \n=\n \n1\n;\n\n        \n}\n \nelse\n \n{\n\n            \nduty_cycle_G\n \n-=\n \n40\n;\n\n        \n}\n\n    \n}\n\n\n    \nif\n \n(\nstate_B\n){\n\n        \nif\n \n(\nduty_cycle_B\n \n>\n \nSECOND_SLICE\n){\n\n            \nstate_B\n \n=\n \n0\n;\n\n        \n}\n \nelse\n \n{\n\n            \nduty_cycle_B\n \n+=\n \n50\n;\n\n        \n}\n\n    \n}\n \nelse\n \n{\n\n        \nif\n \n(\nduty_cycle_B\n \n<\n \n50\n){\n\n            \nstate_B\n \n=\n \n1\n;\n\n        \n}\n \nelse\n \n{\n\n            \nduty_cycle_B\n \n-=\n \n50\n;\n\n        \n}\n\n    \n}\n\n    \nset_timer\n();\n\n    \nstart_timer\n();\n\n    \ndelay_ms\n(\ndelay_time\n);\n\n\n}\n\n\n\n\n\n\n\n\n\nCustomizable mode \n\nIf it is in the customize mode, we are able to increase the proportion of color, to achieve that, just increase/decrease the duty cycle of that color. DELTA_VALUE is used to adjust the amount of duty cycle applied in PWM mode.\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\ncase\n \n4\n:\n\n\n{\n\n    \nif\n(\nduty_cycle_R\n \n>\n \nDELTA_VALUE\n)\n\n        \nduty_cycle_R\n \n-=\n \nDELTA_VALUE\n;\n \n(\nor\n \nadd\n \nthe\n \nDELTA_VALUE\n)\n\n    \nelse\n\n        \nduty_cycle_R\n \n=\n \n0\n;\n\n    \nbreak\n;\n\n\n}\n\n\n\n\n\n\n\nPart4. More idea: the ADC of light-sensitive resistor\n\n\nThe Earth is now facing the serve global warming, it is vital for us to construct a power saving model, consequently Alice and I came out the idea of using the\nADC to detect the light intensity.\n\nConcept of ADC configuration credit to \nmy classmate's hackMD\n (Add later)\nThe stronger the intensity, the dimmer the light to be to saving the energy since this module is aimed for atmosphere night light. \n\n\nADC Code is here\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\ncase\n \n11\n:\n\n\n{\n\n    \n// light ADC mode for keypad key11\n\n    \ncur_state\n \n=\n \nLIGHT_MODE\n;\n\n    \nbreak\n;\n\n\n}\n\n\n\nif\n(\ncur_state\n \n==\n \nLIGHT_MODE\n)\n\n\n{\n\n    \nget_light_resistor\n();\n\n    \nlight\n \n=\n \n255\n-\n((\nresistor_value\n-\nREF_LIGHT\n)\n/\n10\n);\n\n    \nduty_cycle_R\n \n=\n \nlight\n;\n\n    \nduty_cycle_G\n \n=\n \nlight\n;\n\n    \nduty_cycle_B\n \n=\n \nlight\n;\n\n    \nset_timer\n();\n\n    \nstart_timer\n();\n\n\n}\n\n\n\n\n\n\n\nPart5. Done all.\n\n\nReally thanks to my teammate \nchialice123\n who helps me alot during the semester and in the final project making the project score over 90 and overall semester score to be 95 (93 original and +2 adjust), and \nvava24680\n for teaching me some concepts of ADC configuration.\n\n\nProject demo video",
            "title": "Junior 1st sem. STM32 Microprocessor Embedded Lab"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#microprocessor-lab",
            "text": "Fall 2017 \nLecturer:  S.L. Tsao  in CS@NCTU  \nTime: 5EF @EDB27_NCTU 3IJK @EC222_NCTU",
            "title": "Microprocessor Lab"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#microprocessor-lab-final-project",
            "text": "Course Introduction  \nThis course mainly focus on the embedded system understanding, and we use the ARM microarchitecture in this semester.    Goal of this course  \nTo briefly understand the ARM Assembly, how to write C code in the embedded developing board and make a small project from it by your own.    Embedded board spec: \n1.Nucleo STM32L476RG ARM Microarchitecture  \n2.Built-in 400MHz CPU (customizable frequency with internal clock settings provided)  \n3.GPIO Available   Detailed specs      IDE for this course Eclipse  AC6 System Workbench for STM32 where JRE7 is required in your system    1.Download from  Here for Linux version   Lab project and final project  \nThere are 10 labs in this semester on a weekly basis, the first five focus on basic operation of ARM Assembly, namely the lab assignments are\ntypically written in the ARM Assembly, while the last five labs are written in C language, but a embedded-like C language.",
            "title": "Microprocessor Lab Final Project"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#about-my-final-project",
            "text": "Project name: The RGB Ambient light.   Features:  \n1.Fully-customizable RGB proportion control.  \n2.Color cycle speed controller (faster->original) \n3.Light-sensitive resistor ADC ,detecting the background light for light quantity settings  GitHub repo for this final project  Project demo video",
            "title": "About my final project"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part0-origin-of-this-idea-and-preparation",
            "text": "Origin of this idea  \nI once have the fully-customizable dynamic RGB LED backlit keyboard  SteelSeries APEXM 650    On account of having not much time in the end of semester(machine learning final project + compiler design final project.)\nMy  teammate  and I decided to do it.    Preparation of materials and tools for this project  \n1.A STM32L476RG Embedded board \n2.Breadboard \n3.4pin RGB LED*5  Click here \n4.R1000 Resistor \n5.Some Dupont cables",
            "title": "Part0. Origin of this idea and preparation"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part1-circuit-connection",
            "text": "1.Parallel connection of 5 RGB LEDs on the breadboard. \n2.Connect separately to the GPIO pin on the STM32 providing the capability of PWM output. \n3.Connect the keypad to the STM32. \n4.Connect the light-sensitive resistor to GPIO with capability of ADC(Analog-Digital Converter). \n5.The GPIO Connection is like. \n6.Overall GPIO port configuration.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39 GPIOB -> ASCR   |=   0 b1 ;   //turn on the analog controller in PB0  void   keypad_init () //keypad along with GPIO Init together  { \n\n     RCC -> AHB2ENR     |=   0 b00000000000000000000000000000111 ;   //open port A,B,C \n                       //10987654321098765432109876543210 \n     GPIOC -> MODER     &=   0 b11111111111111111111111100000000 ;   //pc 3 2 1 0 as input of keypad \n     GPIOC -> MODER     |=   0 b00000000000000000000000001010101 ; \n     GPIOC -> PUPDR     &=   0 b11111111111111111111111100000000 ; \n     GPIOC -> PUPDR     |=   0 b00000000000000000000000001010101 ; \n     GPIOC -> OSPEEDR   &=   0 b11111111111111111111111100000000 ; \n     GPIOC -> OSPEEDR   |=   0 b00000000000000000000000001010101 ; \n     GPIOC -> ODR       |=   0 b00000000000000000000000000001111 ; \n                       //10987654321098765432109876543210 \n     GPIOB -> MODER     &=   0 b11111111111111110000000011111111 ;   //pb 7 6 5 4 as output of keypad \n     GPIOB -> PUPDR     &=   0 b11111111111111110000000011111111 ; \n     GPIOB -> PUPDR     |=   0 b00000000000000001010101000000000 ;  }  void   GPIO_init_AF ()   //GPIO Alternate Function Init  { \n     /***************pin and alternate function***************       * PB3 + AF1 which is corresponding to TIM2_CH2 RED       * PA1 + AF2 which is corresponding to TIM5_CH2 GREEN       * PA6 + AF2 which is corresponding to TIM3_CH1 BLUE       ********************************************************/ \n                        //10987654321098765432109876543210 \n     GPIOA -> MODER      &=   0 b11111111111111111100111111110011 ; \n     GPIOA -> MODER      |=   0 b00000000000000000010000000001000 ; \n     //PortA Pin        //10987654321098765432109876543210 \n     GPIOA -> AFR [ 0 ]     =    0 b00000010000100000000000000100000 ; \n\n     //PB3 TIM2_CH2 \n     GPIOB -> AFR [ 0 ]     &=   ~ GPIO_AFRL_AFSEL3 ; //AFR[0] LOW \n     GPIOB -> AFR [ 0 ]     |=   ( 0 b0001 << GPIO_AFRL_AFSEL3_Pos ); //PB3 Alternate function mode  }",
            "title": "Part1. Circuit connection"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part2-key-idea-of-this-project",
            "text": "The PWM(Pulse Width Modulation)  Wiki \nPWM cycle (HV/ALL) = The proportion where light lights, the longer HV lasts, the brighter of the certain part of RGB(either one) will do. \nThe Pulse Width can be used to simulate the analog output like this.  PWM Video \nThe same is true of other 3 colors, configuring with the following code and expanations. \n* Basic logic for this project  \nInitialize system -> PWM and timer configuration -> Presskey -> Color changing scheme along with ADC light intensity detection for power saving.  1\n2\n3\n4 int   keypad_value [ 4 ][ 4 ]   =   {{ 0 , 1 , 2 , 3 }, \n                           { 4 , 5 , 6 , 7 }, \n                           { 8 , 9 , 10 , 11 }, \n                           { 12 , 13 , 14 , 15 }};    keypad explanation  \n0 red+ \n1 green+ \n2 blue+ \n3 cycle_speed+ \n4 red- \n5 green- \n6 blue- \n7 customize mode(0 1 2 4 5 6 applicable) \n8 only red \n9 only green \n10 only blue \n11 light ADC mode \n12 red+greren \n13 green+blue \n14 red+blue \n15 off system, remember the last state, s.t. user configuration is not lost after shut down \n* Setup the PWM channel \nRefer to  this pdf  for PWM channel-GPIO port configuration, each port has its corresponding PWM channel and built-in system clock, be sure to make it right!   More understanding and details are written in comments of the following source code. \nPlease refer to  p.1006-1039  of  this pdf  to see how to config the PWM cycle with certain registers in timer.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89 void   Timer_init ()   //Use 3  { \n     // PA3 + AF1 which is corresponding to TIM2_CH1 \n     // PA1 + AF2 which is corresponding to TIM5_CH2 \n     // PA6 + AF2 which is corresponding to TIM3_CH1 \n     RCC -> APB1ENR1   |=   RCC_APB1ENR1_TIM2EN ; \n     RCC -> APB1ENR1   |=   RCC_APB1ENR1_TIM3EN ; \n     RCC -> APB1ENR1   |=   RCC_APB1ENR1_TIM5EN ; \n\n     //setting for timer 2 \n     TIM2 -> CR1   &=   0x0000 ;   //p1027 Turned on the counter as the count up mode \n     TIM2 -> ARR   =   ( uint32_t ) SECOND_SLICE ; //Reload value \n     TIM2 -> PSC   =   ( uint32_t ) COUNT_UP ; //Prescaler \n     TIM2 -> EGR   =   TIM_EGR_UG ;       //update the counter again p1035 \n\n     //setting for timer 3 \n     TIM3 -> CR1   &=   0x0000 ;   //p1027 Turned on the counter as the count up mode \n     TIM3 -> ARR   =   ( uint32_t ) SECOND_SLICE ; //Reload value \n     TIM3 -> PSC   =   ( uint32_t ) COUNT_UP ; //Prescaler \n     TIM3 -> EGR   =   TIM_EGR_UG ; //Reinitialize the counter \n\n     //setting for timer 5 \n     TIM5 -> CR1   &=   0x0000 ;   //p1027 Turned on the counter as the count up mode \n     TIM5 -> ARR   =   ( uint32_t ) SECOND_SLICE ; //Reload value \n     TIM5 -> PSC   =   ( uint32_t ) COUNT_UP ; //Prescaler \n     TIM5 -> EGR   =   TIM_EGR_UG ; //Reinitialize the counter  }  void   PWM_channel_init ()  { \n     /***********************setting for the TIM2_CH2 RED**************************/ \n     // PB3 + AF1 which is corresponding to TIM2_CH2 RED \n     //Output compare 2 mode \n     TIM2 -> CCMR1   &=   ~ TIM_CCMR1_OC2M ; \n     //110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive \n     TIM2 -> CCMR1   |=   ( 0 b0110   <<   TIM_CCMR1_OC2M_Pos ); \n\n     //Output Compare 2 Preload Enable \n     TIM2 -> CCMR1   &=   ~ TIM_CCMR1_OC2PE ; //OCxPE \n     //1: enable TIMx_CCR1 Preload \n     TIM2 -> CCMR1   |=   ( 0 b1   <<   TIM_CCMR1_OC2PE_Pos ); \n     //enable auto reload pre-load \n     TIM2 -> CR1   |=   TIM_CR1_ARPE ; \n\n     //duty cycle initial 50 (CCR2/ARR) \n     //TIM2->CCR2 = duty_cycle_R; \n     //enable output compare \n     TIM2 -> CCER   |=   TIM_CCER_CC2E ; \n\n     /***********************setting for the TIM5_CH2 GREEN**************************/ \n     // PA1 + AF2 which is corresponding to TIM5_CH2 GREEN \n     //Output compare 2 mode \n     TIM5 -> CCMR1   &=   ~ TIM_CCMR1_OC2M ; \n     //110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive \n     TIM5 -> CCMR1   |=   ( 0 b0110   <<   TIM_CCMR1_OC2M_Pos ); \n\n     //Output Compare 2 Preload Enable \n     TIM5 -> CCMR1   &=   ~ TIM_CCMR1_OC2PE ; //OCxPE \n     //1: enable TIMx_CCR1 Preload \n     TIM5 -> CCMR1   |=   ( 0 b1   <<   TIM_CCMR1_OC2PE_Pos ); \n     //enable auto reload pre-load \n     TIM5 -> CR1   |=   TIM_CR1_ARPE ; \n\n     //duty cycle initial 50 (CCR2/ARR) \n     //TIM5->CCR2 = duty_cycle_G; \n     //enable output compare \n     TIM5 -> CCER   |=   TIM_CCER_CC2E ; \n\n     /***********************setting for the TIM3_CH1 BLUE**************************/ \n     // PA6 + AF2 which is corresponding to TIM3_CH1 BLUE \n     //Output compare 2 mode \n     TIM3 -> CCMR1   &=   ~ TIM_CCMR1_OC1M ; \n     //110: PWM mode 1: TIMx_CNT<TIMx_CCR2-->active, or inactive \n     TIM3 -> CCMR1   |=   ( 0 b0110   <<   TIM_CCMR1_OC1M_Pos ); \n\n     //Output Compare 2 Preload Enable \n     TIM3 -> CCMR1   &=   ~ TIM_CCMR1_OC1PE ; //OCxPE \n     //1: enable TIMx_CCR1 Preload \n     TIM3 -> CCMR1   |=   ( 0 b1   <<   TIM_CCMR1_OC1PE_Pos ); \n     //enable auto reload pre-load \n     TIM3 -> CR1   |=   TIM_CR1_ARPE ; \n\n     //duty cycle initial 50 (CCR2/ARR) \n     //TIM3->CCR1 = duty_cycle_B; \n     //enable output compare \n     TIM3 -> CCER   |=   TIM_CCER_CC1E ;  }    *",
            "title": "Part2. Key idea of this project"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part3-its-time-to-change-the-color",
            "text": "Initialize to different duty cycle.  \nEach color has its own PWM cycle, by setting the PWM cycle differently, we will be able to interleave 3 colors\nand mixing them together since there pulse waves have \"time shifting (or say phase shifting)\" to each other.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28 #define RED_START 10  #define GREEN_START 91  #define BLUE_START 172  duty_cycle_R   =   RED_START ;  duty_cycle_G   =   GREEN_START ;  duty_cycle_B   =   BLUE_START ;  int   main ()  { \n     //use the time delay mode to make the interleaving and the color changing scheme \n     fpu_enable (); \n     keypad_init (); \n     GPIO_init_AF (); \n     Timer_init (); \n     configureADC (); \n     startADC (); \n     duty_cycle_R   =   RED_START ; \n     duty_cycle_G   =   GREEN_START ; \n     duty_cycle_B   =   BLUE_START ; \n     cur_state   =   CYCLE_MODE ; \n     while ( 1 ) \n     { \n         PWM_channel_init (); \n         chromatic_scheme ( keypad_scan ()); \n     } \n     return   0 ;  }     Increase, decrease and cycle.  \nstate_color is the state indicating whether to increase the pulse cycle or decrease, with an view to simulating the sin-wave-like phase wave.     1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47 void   cycle_mode ( int   delay_time ){ \n     PWM_channel_init (); \n     if   ( state_R ){ \n         if   ( duty_cycle_R   >   SECOND_SLICE ){ \n             state_R   =   0 ; \n         }   else   { \n             duty_cycle_R   +=   20 ; \n         } \n     }   else   { \n         if   ( duty_cycle_R   <   20 ){ \n             state_R   =   1 ; \n         }   else   { \n             duty_cycle_R   -=   20 ; \n         } \n     } \n\n     if   ( state_G ){ \n         if   ( duty_cycle_G   >   SECOND_SLICE ){ \n             state_G   =   0 ; \n     }   else   { \n         duty_cycle_G   +=   40 ; \n         } \n     }   else   { \n         if   ( duty_cycle_G   <   40 ){ \n             state_G   =   1 ; \n         }   else   { \n             duty_cycle_G   -=   40 ; \n         } \n     } \n\n     if   ( state_B ){ \n         if   ( duty_cycle_B   >   SECOND_SLICE ){ \n             state_B   =   0 ; \n         }   else   { \n             duty_cycle_B   +=   50 ; \n         } \n     }   else   { \n         if   ( duty_cycle_B   <   50 ){ \n             state_B   =   1 ; \n         }   else   { \n             duty_cycle_B   -=   50 ; \n         } \n     } \n     set_timer (); \n     start_timer (); \n     delay_ms ( delay_time );  }     Customizable mode  \nIf it is in the customize mode, we are able to increase the proportion of color, to achieve that, just increase/decrease the duty cycle of that color. DELTA_VALUE is used to adjust the amount of duty cycle applied in PWM mode.   1\n2\n3\n4\n5\n6\n7\n8 case   4 :  { \n     if ( duty_cycle_R   >   DELTA_VALUE ) \n         duty_cycle_R   -=   DELTA_VALUE ;   ( or   add   the   DELTA_VALUE ) \n     else \n         duty_cycle_R   =   0 ; \n     break ;  }",
            "title": "Part3. It's time to change the color."
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part4-more-idea-the-adc-of-light-sensitive-resistor",
            "text": "The Earth is now facing the serve global warming, it is vital for us to construct a power saving model, consequently Alice and I came out the idea of using the\nADC to detect the light intensity. \nConcept of ADC configuration credit to  my classmate's hackMD  (Add later)\nThe stronger the intensity, the dimmer the light to be to saving the energy since this module is aimed for atmosphere night light.   ADC Code is here   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17 case   11 :  { \n     // light ADC mode for keypad key11 \n     cur_state   =   LIGHT_MODE ; \n     break ;  }  if ( cur_state   ==   LIGHT_MODE )  { \n     get_light_resistor (); \n     light   =   255 - (( resistor_value - REF_LIGHT ) / 10 ); \n     duty_cycle_R   =   light ; \n     duty_cycle_G   =   light ; \n     duty_cycle_B   =   light ; \n     set_timer (); \n     start_timer ();  }",
            "title": "Part4. More idea: the ADC of light-sensitive resistor"
        },
        {
            "location": "/univ_notes/mpslab/mpslab/#part5-done-all",
            "text": "Really thanks to my teammate  chialice123  who helps me alot during the semester and in the final project making the project score over 90 and overall semester score to be 95 (93 original and +2 adjust), and  vava24680  for teaching me some concepts of ADC configuration.  Project demo video",
            "title": "Part5. Done all."
        },
        {
            "location": "/univ_notes/uav_autopilot/uav_autopilot/",
            "text": "UAV Drone autopilot, computer vision and image processing.\n\n\nSpring 2018\n\nLecturer: \nK.W. Chen\n in CS@NCTU \n\nTime: 4IJK @EC330_NCTU\n\n\nLab1. Introduction to Open CV and installation Mar 01, 2018\n\n\nLab1 pdf\n\n\nInstall Open CV\n\n\n\n\nIn the Ubuntu 16.04 64bit\nRequired dependencies are the followings \n\n1.Git \n\n2.Python 2.6 or later and Numpy 1.5 or later with developer packages (python-dev, python-numpy) \n\n3.CMake 2.6 or higher \n\n4.GCC 4.4.x or later \n\n\n\n\n1\nsudo apt-get install libopencv-dev python-opencv\n\n\n\n\n\n\nOnce installed\n\n\n1\npkg-config --modversion opencv\n\n\n\n\n\n\nIf the version is shown, then we're good to rock with opencv. \n\n\n\n\nBuild your opencv_file.cpp with CMake or g++ standards\n\n\n\n\n1.With CMake (Don't forget to add CMakeLists.txt)\n\n\n1\n2\n3\n4\n5\ncmake_minimum_required(VERSION\n \n2.8)\n\n\nproject(\n \n<project_name>\n \n)\n\n\nfind_package(\n \nOpenCV\n \nREQUIRED\n \n)\n\n\nadd_executable(\n \n<project_name>\n \n<project_name>.cpp\n \n)\n\n\ntarget_link_libraries(\n \n<project_name>\n \n${OpenCV_LIBS}\n \n)\n\n\n\n\n\n\n\n2.With g++ and flags for opencv libraries\n\n\n1\ng++ lab1-2.cpp `pkg-config --cflags --libs opencv`\n\n\n\n\n\n\nToday's course contents\n\n\nBasic understanding of image processing and image data format.\n\nCourse week1 pdf\n\n\nBilinear Interpolation\n\nBasically ,this is an algorithm aimed for image transformation in this lab. \n\nThe interpolated value of a point is a reversely-weighted average of the neighboring points, \n\nsuch method is quite useful in the image transformation.",
            "title": "Junior 2nd sem. UAV Autopilot and Image Processing"
        },
        {
            "location": "/univ_notes/uav_autopilot/uav_autopilot/#uav-drone-autopilot-computer-vision-and-image-processing",
            "text": "Spring 2018 \nLecturer:  K.W. Chen  in CS@NCTU  \nTime: 4IJK @EC330_NCTU",
            "title": "UAV Drone autopilot, computer vision and image processing."
        },
        {
            "location": "/univ_notes/uav_autopilot/uav_autopilot/#lab1-introduction-to-open-cv-and-installation-mar-01-2018",
            "text": "Lab1 pdf",
            "title": "Lab1. Introduction to Open CV and installation Mar 01, 2018"
        },
        {
            "location": "/univ_notes/uav_autopilot/uav_autopilot/#install-open-cv",
            "text": "In the Ubuntu 16.04 64bit\nRequired dependencies are the followings  \n1.Git  \n2.Python 2.6 or later and Numpy 1.5 or later with developer packages (python-dev, python-numpy)  \n3.CMake 2.6 or higher  \n4.GCC 4.4.x or later    1 sudo apt-get install libopencv-dev python-opencv   Once installed  1 pkg-config --modversion opencv   If the version is shown, then we're good to rock with opencv.    Build your opencv_file.cpp with CMake or g++ standards   1.With CMake (Don't forget to add CMakeLists.txt)  1\n2\n3\n4\n5 cmake_minimum_required(VERSION   2.8)  project(   <project_name>   )  find_package(   OpenCV   REQUIRED   )  add_executable(   <project_name>   <project_name>.cpp   )  target_link_libraries(   <project_name>   ${OpenCV_LIBS}   )    2.With g++ and flags for opencv libraries  1 g++ lab1-2.cpp `pkg-config --cflags --libs opencv`",
            "title": "Install Open CV"
        },
        {
            "location": "/univ_notes/uav_autopilot/uav_autopilot/#todays-course-contents",
            "text": "Basic understanding of image processing and image data format. Course week1 pdf  Bilinear Interpolation \nBasically ,this is an algorithm aimed for image transformation in this lab.  \nThe interpolated value of a point is a reversely-weighted average of the neighboring points,  \nsuch method is quite useful in the image transformation.",
            "title": "Today's course contents"
        },
        {
            "location": "/univ_notes/internet_security/internet_security/",
            "text": "",
            "title": "Junior 2nd sem. Internet Security"
        },
        {
            "location": "/programming_practice/leetcode_OJ/lcojindex/",
            "text": "Index of leetcode_OJ\n\n\nleetcode_OJ(Old blog, from google blogger)\n \n\n\nWC70",
            "title": "Index"
        },
        {
            "location": "/programming_practice/leetcode_OJ/lcojindex/#index-of-leetcode_oj",
            "text": "leetcode_OJ(Old blog, from google blogger)    WC70",
            "title": "Index of leetcode_OJ"
        },
        {
            "location": "/programming_practice/leetcode_OJ/WC70/",
            "text": "leetcode_OJ WC70 \u89e3\u984c\u5fc3\u5f97\n\n\n\n\nContest time: Feb 4, 2018\n\n\nVirtual contest by myself: Mar 4, 2018\n\n\n\n\nPA.\n\n\n779. K-th Symbol in Grammar\n\n\n\n\n\u601d\u8def\uff1a\u627e\u898f\u5f8b\uff0c\u524d\u9762\u7684N\uff0c\u5be6\u969b\u4e0a\u662f\u969c\u773c\u6cd5\u3002\n\u4ee5\u4e0b\u7684N\u662f\u4e00(1-based)\n2 3 5 8 9 12 14 15\n\u5176-1\u5f8c\u4e8c\u9032\u4f4d\u8868\u793a\u6cd5\u70ba\uff1a\n0001\n0010\n0100\n0111\n1000\n1011\n1101\n1110\n\u6e1b\u4e00\u5f8c\u6709\u5947\u6578\u500b\u4e00\u5247\u70ba1 \u5426\u5247\u70ba0\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass\n \nSolution\n\n\n{\n\n\npublic\n:\n\n    \nint\n \nkthGrammar\n(\nint\n \nnin\n,\n \nint\n \nkin\n)\n\n    \n{\n\n        \nint\n \ncnt\n \n=\n \n0\n;\n\n        \nkin\n--\n;\n\n        \nwhile\n(\nkin\n)\n\n        \n{\n\n            \nif\n(\nkin\n&\n1\n)\n\n            \n{\n\n                \ncnt\n++\n;\n\n            \n}\n\n            \nkin\n>>=\n1\n;\n\n        \n}\n\n        \nreturn\n \ncnt\n&\n1\n;\n\n    \n}\n\n\n};\n\n\n\n\n\n\n\nPB.\n\n\n\u88ab\u9396\u4f4f\u770b\u4e0d\u5230\uff20\uff20\uff0c\u4e8b\u5f8c\u8cfd\uff0c\u9700\u8981\u5347\u7d1a\u6210\u9ad8\u7d1a\u6703\u54e1\u624d\u6709\uff0c\u770b\u984c\u76ee\u662f\u5207\u5272\u4e8c\u5143\u6a39\n\n\nPC.\n\n\n777. Swap Adjacent in LR String\n\n\n\n\n\u932f\u8aa4\u601d\u8def \uff1a\u60f3\u8aaa\u7528\u64f4\u6563\u89e3\u6cd5\uff0cdfs\u4e0b\u53bb\u8996\u60c5\u6cc1\u4ea4\u63db\uff0c\u7136\u5403\u4e86\u4e00\u500b\u5927RE(stack overflow)\n\u5f8c\u4f86\u767c\u73fe\u662f\u5fd8\u4e86\u5bebvisited\uff1d \uff1d\uff0c\u6839\u672c\u8822\uff0c\u770b\u4f86\u9019\u65b9\u9762\u9084\u5f97\u591a\u591a\u78e8\u7df4\u9020\u5316\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n//Runtime Error (stack overflow)\n\n\nclass\n \nSolution\n \n{\n\n\npublic\n:\n\n    \nbool\n \ncan\n \n=\n \nfalse\n;\n\n    \nbool\n \ncanTransform\n(\nstring\n \nstart\n,\n \nstring\n \nend\n)\n\n    \n{\n\n        \nif\n(\nstart\n \n==\n \nend\n)\n\n            \nreturn\n \n1\n;\n\n        \nelse\n\n        \n{\n\n            \ndfs\n(\nstart\n,\n \nend\n,\n \n0\n,\n \nstart\n.\nsize\n()\n-\n1\n);\n\n        \n}\n\n        \nreturn\n \ncan\n;\n\n    \n}\n\n    \nvoid\n \ndfs\n(\nstring\n \nstart\n,\n \nstring\n \nend\n,\n \nint\n \nlptr\n,\n \nint\n \nrptr\n)\n \n//quick sort-like recusrion\n\n    \n{\n\n        \nif\n(\nlptr\n \n>=\n \nrptr\n)\n \n//length end\n\n        \n{\n\n            \nreturn\n \n;\n\n        \n}\n\n        \nif\n(\nstart\n \n==\n  \nend\n)\n\n        \n{\n\n            \ncan\n \n=\n \ntrue\n;\n\n            \nreturn\n \n;\n\n        \n}\n\n        \nint\n \nlen\n \n=\n \nstart\n.\nsize\n()\n \n>>\n \n1\n;\n\n        \nint\n \nlptr1\n \n=\n \nlptr\n,\n \nrptr1\n \n=\n \nlen\n;\n\n        \nint\n \nlptr2\n \n=\n \nlen\n \n+\n \n1\n,\n \nrptr2\n \n=\n \nrptr\n;\n\n        \nfor\n(\nint\n \npos\n \n=\n \nlptr\n;\npos\n \n<=\n \nrptr\n;\npos\n++\n)\n\n        \n{\n\n            \nif\n(\nstart\n[\npos\n]\n==\n'X'\n \n&&\n \nstart\n[\npos\n+\n1\n]\n==\n'L'\n)\n\n            \n{\n\n                \nswap\n(\nstart\n[\npos\n],\nstart\n[\npos\n+\n1\n]);\n\n            \n}\n\n            \nelse\n \nif\n(\nstart\n[\npos\n]\n==\n'R'\n \n&&\n \nstart\n[\npos\n+\n1\n]\n==\n'X'\n)\n\n            \n{\n\n                \nswap\n(\nstart\n[\npos\n],\nstart\n[\npos\n+\n1\n]);\n\n            \n}\n\n        \n}\n\n        \ndfs\n(\nstart\n,\n \nend\n,\n \nlptr1\n,\n \nrptr1\n);\n\n        \ndfs\n(\nstart\n,\n \nend\n,\n \nlptr2\n,\n \nrptr2\n);\n\n\n    \n}\n\n\n};\n\n\n\n\n\n\n\n\n\n\u6b63\u78ba\u601d\u8def\uff0c\u53c3\u8003\u4e86\u8a0e\u8ad6\u5340\u63d0\u793a\uff1a\u7531\u65bcR\u53ea\u80fd\u5411\u53f3\uff0c\u800cL\u53ea\u80fd\u5411\u5de6\uff0c\u56e0\u6b64\u6211\u5011\u53ef\u4ee5\u900f\u904e\u5169\u500b\u6307\u6a19\u5728\u5169\u5b57\u4e32\u4e2d\u8dd1\uff0c\u627e\u5230\u7b2c\u4e00\u500b\u975eX\u7684\u5b57\u5143\uff0c\u82e5\u4e0d\u4e00\u6a23\u5247\u5fc5\u7136\u7121\u6cd5\u66ff\u63db\uff0c\u800c\u8981\u4f7f\u5f97R\u80fd\u5920\u66ff\u63db\u6210\u7d50\u679c\n\u552f\u6709start \u7684 R \u8f03 end \u7684 R \u5de6\u5074\uff0c\u624d\u6709\u6a5f\u6703\u5411\u53f3\uff0c\u82e5R\u5df2\u7d93\u592a\u53f3\u908a\u4e86\uff08\u4ea6\u5373\u8d85\u51faend\u7684R \uff09 \u4fbf\u662f\u63db\u4e0d\u904e\u53bb\u4e86\uff0c\u540c\u7406\u53ef\u5f97L\u7684\u6982\u5ff5\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\nclass\n \nSolution\n \n{\n\n\npublic\n:\n\n    \nbool\n \ncan\n \n=\n \nfalse\n;\n\n    \nbool\n \ncanTransform\n(\nstring\n \nstart\n,\n \nstring\n \nend\n)\n\n    \n{\n\n        \nif\n(\nstart\n \n==\n \nend\n)\n\n            \nreturn\n \n1\n;\n\n        \nelse\n \nif\n(\nstart\n.\nsize\n()\n \n!=\n \nend\n.\nsize\n())\n\n        \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n\n\n        \nint\n \nlen\n \n=\n \nstart\n.\nsize\n();\n\n        \nint\n \nptr1\n \n=\n \n0\n,\n \nptr2\n \n=\n \n0\n;\n\n        \nwhile\n(\nptr1\n \n<\n \nlen\n \n&&\n \nptr2\n \n<\n \nlen\n)\n \n//both in the boundary\n\n        \n{\n\n            \nwhile\n(\nptr1\n \n<\n \nlen\n \n&&\n \nstart\n[\nptr1\n]\n \n==\n \n'X'\n)\n \n//iterate till not X in start\n\n                \nptr1\n++\n;\n\n\n            \nwhile\n(\nptr2\n \n<\n \nlen\n \n&&\n \nend\n[\nptr2\n]\n \n==\n \n'X'\n)\n \n//iterate till not X in end\n\n                \nptr2\n++\n;\n\n\n            \nif\n(\nstart\n[\nptr1\n]\n \n!=\n \nend\n[\nptr2\n])\n \n//example  XL RX they are different, unable to swap\n\n                \nreturn\n \n0\n;\n\n\n            \n//iterate till next non X, both increment\n\n\n            \nif\n(\nstart\n[\nptr1\n]\n \n==\n \n'R'\n \n&&\n \nptr1\n \n>\n \nptr2\n)\n \n//R of start is right to the R of end,\n\n            \n//R can only move right but this situation needs R to move left, which is a contradiction\n\n            \n/*\n\n\n            \u6ce8\u610f\u4e0d\u80fd\u5bebptr1 >= ptr2 \u56e0\u70ba XRXL XRLX   XR\u90e8\u4efd\u5df2\u7d93\u6eff\u8db3\uff0c\u662f XR RX\u624d\u4e0d\u884c\uff01\uff01\n\n\n            */\n\n            \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n            \nelse\n \nif\n(\nstart\n[\nptr1\n]\n \n==\n \n'L'\n \n&&\n \nptr2\n \n>\n \nptr1\n)\n\n            \n//L of start is left to the L of end,\n\n            \n//L can only move left but this situation needs L to move right, which is a contradiction\n\n            \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n            \nptr1\n++\n;\n\n            \nptr2\n++\n;\n\n\n        \n}\n\n        \nreturn\n \n1\n;\n\n    \n}\n\n\n\n};",
            "title": "WC70"
        },
        {
            "location": "/programming_practice/leetcode_OJ/WC70/#leetcode_oj-wc70",
            "text": "Contest time: Feb 4, 2018  Virtual contest by myself: Mar 4, 2018",
            "title": "leetcode_OJ WC70 \u89e3\u984c\u5fc3\u5f97"
        },
        {
            "location": "/programming_practice/leetcode_OJ/WC70/#pa",
            "text": "779. K-th Symbol in Grammar   \u601d\u8def\uff1a\u627e\u898f\u5f8b\uff0c\u524d\u9762\u7684N\uff0c\u5be6\u969b\u4e0a\u662f\u969c\u773c\u6cd5\u3002\n\u4ee5\u4e0b\u7684N\u662f\u4e00(1-based)\n2 3 5 8 9 12 14 15\n\u5176-1\u5f8c\u4e8c\u9032\u4f4d\u8868\u793a\u6cd5\u70ba\uff1a\n0001\n0010\n0100\n0111\n1000\n1011\n1101\n1110\n\u6e1b\u4e00\u5f8c\u6709\u5947\u6578\u500b\u4e00\u5247\u70ba1 \u5426\u5247\u70ba0    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 class   Solution  {  public : \n     int   kthGrammar ( int   nin ,   int   kin ) \n     { \n         int   cnt   =   0 ; \n         kin -- ; \n         while ( kin ) \n         { \n             if ( kin & 1 ) \n             { \n                 cnt ++ ; \n             } \n             kin >>= 1 ; \n         } \n         return   cnt & 1 ; \n     }  };",
            "title": "PA."
        },
        {
            "location": "/programming_practice/leetcode_OJ/WC70/#pb",
            "text": "\u88ab\u9396\u4f4f\u770b\u4e0d\u5230\uff20\uff20\uff0c\u4e8b\u5f8c\u8cfd\uff0c\u9700\u8981\u5347\u7d1a\u6210\u9ad8\u7d1a\u6703\u54e1\u624d\u6709\uff0c\u770b\u984c\u76ee\u662f\u5207\u5272\u4e8c\u5143\u6a39",
            "title": "PB."
        },
        {
            "location": "/programming_practice/leetcode_OJ/WC70/#pc",
            "text": "777. Swap Adjacent in LR String   \u932f\u8aa4\u601d\u8def \uff1a\u60f3\u8aaa\u7528\u64f4\u6563\u89e3\u6cd5\uff0cdfs\u4e0b\u53bb\u8996\u60c5\u6cc1\u4ea4\u63db\uff0c\u7136\u5403\u4e86\u4e00\u500b\u5927RE(stack overflow)\n\u5f8c\u4f86\u767c\u73fe\u662f\u5fd8\u4e86\u5bebvisited\uff1d \uff1d\uff0c\u6839\u672c\u8822\uff0c\u770b\u4f86\u9019\u65b9\u9762\u9084\u5f97\u591a\u591a\u78e8\u7df4\u9020\u5316    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44 //Runtime Error (stack overflow)  class   Solution   {  public : \n     bool   can   =   false ; \n     bool   canTransform ( string   start ,   string   end ) \n     { \n         if ( start   ==   end ) \n             return   1 ; \n         else \n         { \n             dfs ( start ,   end ,   0 ,   start . size () - 1 ); \n         } \n         return   can ; \n     } \n     void   dfs ( string   start ,   string   end ,   int   lptr ,   int   rptr )   //quick sort-like recusrion \n     { \n         if ( lptr   >=   rptr )   //length end \n         { \n             return   ; \n         } \n         if ( start   ==    end ) \n         { \n             can   =   true ; \n             return   ; \n         } \n         int   len   =   start . size ()   >>   1 ; \n         int   lptr1   =   lptr ,   rptr1   =   len ; \n         int   lptr2   =   len   +   1 ,   rptr2   =   rptr ; \n         for ( int   pos   =   lptr ; pos   <=   rptr ; pos ++ ) \n         { \n             if ( start [ pos ] == 'X'   &&   start [ pos + 1 ] == 'L' ) \n             { \n                 swap ( start [ pos ], start [ pos + 1 ]); \n             } \n             else   if ( start [ pos ] == 'R'   &&   start [ pos + 1 ] == 'X' ) \n             { \n                 swap ( start [ pos ], start [ pos + 1 ]); \n             } \n         } \n         dfs ( start ,   end ,   lptr1 ,   rptr1 ); \n         dfs ( start ,   end ,   lptr2 ,   rptr2 ); \n\n     }  };     \u6b63\u78ba\u601d\u8def\uff0c\u53c3\u8003\u4e86\u8a0e\u8ad6\u5340\u63d0\u793a\uff1a\u7531\u65bcR\u53ea\u80fd\u5411\u53f3\uff0c\u800cL\u53ea\u80fd\u5411\u5de6\uff0c\u56e0\u6b64\u6211\u5011\u53ef\u4ee5\u900f\u904e\u5169\u500b\u6307\u6a19\u5728\u5169\u5b57\u4e32\u4e2d\u8dd1\uff0c\u627e\u5230\u7b2c\u4e00\u500b\u975eX\u7684\u5b57\u5143\uff0c\u82e5\u4e0d\u4e00\u6a23\u5247\u5fc5\u7136\u7121\u6cd5\u66ff\u63db\uff0c\u800c\u8981\u4f7f\u5f97R\u80fd\u5920\u66ff\u63db\u6210\u7d50\u679c\n\u552f\u6709start \u7684 R \u8f03 end \u7684 R \u5de6\u5074\uff0c\u624d\u6709\u6a5f\u6703\u5411\u53f3\uff0c\u82e5R\u5df2\u7d93\u592a\u53f3\u908a\u4e86\uff08\u4ea6\u5373\u8d85\u51faend\u7684R \uff09 \u4fbf\u662f\u63db\u4e0d\u904e\u53bb\u4e86\uff0c\u540c\u7406\u53ef\u5f97L\u7684\u6982\u5ff5    1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49 class   Solution   {  public : \n     bool   can   =   false ; \n     bool   canTransform ( string   start ,   string   end ) \n     { \n         if ( start   ==   end ) \n             return   1 ; \n         else   if ( start . size ()   !=   end . size ()) \n         { \n             return   0 ; \n         } \n\n         int   len   =   start . size (); \n         int   ptr1   =   0 ,   ptr2   =   0 ; \n         while ( ptr1   <   len   &&   ptr2   <   len )   //both in the boundary \n         { \n             while ( ptr1   <   len   &&   start [ ptr1 ]   ==   'X' )   //iterate till not X in start \n                 ptr1 ++ ; \n\n             while ( ptr2   <   len   &&   end [ ptr2 ]   ==   'X' )   //iterate till not X in end \n                 ptr2 ++ ; \n\n             if ( start [ ptr1 ]   !=   end [ ptr2 ])   //example  XL RX they are different, unable to swap \n                 return   0 ; \n\n             //iterate till next non X, both increment \n\n             if ( start [ ptr1 ]   ==   'R'   &&   ptr1   >   ptr2 )   //R of start is right to the R of end, \n             //R can only move right but this situation needs R to move left, which is a contradiction \n             /*              \u6ce8\u610f\u4e0d\u80fd\u5bebptr1 >= ptr2 \u56e0\u70ba XRXL XRLX   XR\u90e8\u4efd\u5df2\u7d93\u6eff\u8db3\uff0c\u662f XR RX\u624d\u4e0d\u884c\uff01\uff01              */ \n             { \n                 return   0 ; \n             } \n             else   if ( start [ ptr1 ]   ==   'L'   &&   ptr2   >   ptr1 ) \n             //L of start is left to the L of end, \n             //L can only move left but this situation needs L to move right, which is a contradiction \n             { \n                 return   0 ; \n             } \n             ptr1 ++ ; \n             ptr2 ++ ; \n\n         } \n         return   1 ; \n     }  };",
            "title": "PC."
        }
    ]
}