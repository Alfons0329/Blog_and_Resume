# leetcode_OJ WC95 解題心得
* Contest time: Aug 12, 2018

## [888. Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/description/) Map的運用
* 題意：找只在自己的句子中出現過一次而對方未出現的詞彙
* 思路：水題，map計數跑兩次即可。
* 分析：Time complexity O(N), Space complexity O(N)
```cpp
class Solution
{
public:
    vector<string> uncommonFromSentences(string A, string B)
    {
        map<string, int>mymap;
        map<string, int>mymap2;
        stringstream ss(A);
        stringstream ss2(B);

        vector<string> stra;
        vector<string> strb;
        vector<string> res;
        string tmp;

        while(ss >> tmp)
        {
            stra.push_back(tmp);
        }

        while(ss2 >> tmp)
        {
            strb.push_back(tmp);
        }

        for(int i = 0; i < stra.size(); i++)
        {
            mymap[stra[i]]++;
        }
        for(int i = 0; i < strb.size(); i++)
        {
            mymap2[strb[i]]++;
        }

        for(map<string, int>::iterator it = mymap.begin(); it != mymap.end(); it++)
        {
            if(it->second == 1)
            {
                if(mymap2[it->first] == 0)
                {
                    res.push_back(it->first);
                }
            }
        }

        for(map<string, int>::iterator it = mymap2.begin(); it != mymap2.end(); it++)
        {
            if(it->second == 1)
            {

                if(mymap[it->first] == 0)
                {
                    res.push_back(it->first);
                }
            }
        }
        return res;
    }
};
```

## [889. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/description/)
* 題意：矩陣中逆時針旋轉，問界內的座標
* 思路：模擬，先從題目給的圖片可看出行走的距離是一個1 1 2 2 3 3 4 4 5 5 6 6每兩組遞增一次一，一樣用`for loop + dx dy (或說drow dcolumn)代表要走的方向`，每次走一點看看是否在界內即可。
`不用想太難，想說還要自己建一個grid在看是否界內，這樣太麻煩，只要想像成有無限大的地圖持續走訪，看看是否在邊界即可`
* 分析：Time complexity O(max(ROW, COL) ^ 2), Space complexity O(ROW * COL)
```cpp
class Solution
{
public:
    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0)
    {
        //1 1 2 2 3 3 4 4 5 5 6 6
        //0 1 2 3 4 5 6 8 7 8 9 10* increase if it is in the odd number
        int rpos = r0, cpos = c0, dir = 0, go = 1;
        int cnt = 0, ans_cnt = 0;
        int dr[4] = {0, 1, 0, -1};
        int dc[4] = {1, 0, -1, 0};
        vector<vector<int>> res;

        //push back the start position
        res.push_back({rpos, cpos});
        ans_cnt++;
        while(ans_cnt < R * C)
        {
            for(int i = 1; 890. Possible Bipartitioni <= go; i++)
            {
                rpos += dr[dir];
                cpos += dc[dir];
                if(rpos >= 0 && rpos < R && cpos >=0 && cpos < C) //push back th eanswer if it is in the grid
                {
                    res.push_back({rpos, cpos});
                    ans_cnt++;
                }
            }

            if(cnt & 1) //to make  1 1 2 2 3 3 4 4 5 5 sequence
            {
                go++;
            }
            cnt++;

            dir++;
            dir %= 4; //change direction
        }
        return res;
    }
};

```

## [890. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/description/)
* 題意：每一個人都討厭自己以外的某人，問如何分成兩組使每一組裡面的所有人不會互相討厭
* 思路：題意如同
* 分析：Time complexity O(N), Space complexity O(N)
