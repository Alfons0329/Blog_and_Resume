# leetcode_OJ WC98 99 100 解題心得
* 暑假最後因實習進度交接，有點累，打了weekly contest結果懶得更新，這次一次更新吧
* Contest time WC98: Aug 19, 2018
* Contest time WC99: Aug 26, 2018
* Contest time WC100: Sep 2, 2018

# WC98 
##[PA. 888. Fair Candy Swap](https://leetcode.com/contest/weekly-contest-98/problems/fair-candy-swap/) 水題
* 題意:兩人各持有數堆糖果，每一堆有n個糖果，問各自交換哪一堆可以讓他們兩個的糖果數量一樣
* 思路:直接做，兩個人一樣取平均，暴力找即可。
* 分析:Time complexity: O(N^2), Space complexity O(N)

```cpp
class Solution 
{
public:
    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) 
    {
        int suma, sumb, flg;
        suma = sumb = 0;
        flg = 0;
        vector<int> res;
        for(int i = 0; i < A.size(); i++)
        {
            suma += A[i];
        }
        for(int i = 0; i < B.size(); i++)
        {
            sumb += B[i];
        }
        int fair = (suma + sumb) / 2;
        for(int i = 0; i < A.size(); i++)
        {
            for(int j = 0; j < B.size(); j++)
            {
                if(suma - A[i] + B[j] == sumb - B[j] + A[i])
                {
                    res.push_back(A[i]);
                    res.push_back(B[j]);
                    flg = 1;
                    break;    
                }
            }
            if(flg)
            {
                break;
            }
        }
        return res;
    }
    bool check(vector<int>& A, vector<int>& B)
    {
        int suma, sumb;
        suma = sumb = 0;
        for(int i = 0; i < A.size(); i++)
        {
            suma += A[i];
        }
        for(int i = 0; i < B.size(); i++)
        {
            sumb += B[i];
        }
        return (suma == sumb) && (suma) && (sumb);//should be more than zero
    }
}; 
```
##[PB. 890. Find and Replace Pattern](https://leetcode.com/contest/weekly-contest-98/problems/find-and-replace-pattern/) string + map
* 題意:找出趨勢一樣的單字，在此趨勢一樣是指英文字出先的『頻率、方式』一致，例如 aabb = ccbb = jjkk , apple = knnrx 等
* WA思路:趨勢一樣代表說，我下一個是不一樣的字母，則你也是;我如果是一樣的則你也要一樣，這樣直接做即可（但是接下來會遇到一個問題，稍後下方『缺失分析』會提及）
```cpp
class Solution 
{
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) 
    {
        vector<string> res;
        for(auto it: words)
        {
            if(check(it, pattern))
            {
                res.push_back(it);
            }
        }
        return res;
    }
    bool check(string to_chk, string pat)
    {
        if(to_chk.size() != pat.size())
        {
            return false;
        }
        for(int i = 0; i < to_chk.size() - 1; i++)
        {
            if(to_chk[i] == to_chk[i + 1]) //趨勢要一致
            {
                if(pat[i] != pat[i + 1])
                {
                    return false;
                }
            }
            else
            {
                if(pat[i] == pat[i + 1]) //趨勢要一致
                {
                    return false;
                }
            }
        }
        return true;
    }
};
```
* 缺失分析:WA的原因在於，這樣會把aba =  xyx = abc 但實際上這題要求連**每一個字母出現頻率也要一樣**，因此最後a b c各自只有一個並不屬於同一類
* 改進思路:多一個map來統計，並且對照組的map內容要和pattern一樣，在英文字母一樣的時候不用管，不一樣時要看各自map內容物是否相等，否則返回false

```cpp
class Solution 
{
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) 
    {
        vector<string> res;
        for(auto it: words)
        {
            if(check(it, pattern))
            {
                res.push_back(it);
            }
        }
        return res;
    }
    bool check(string to_chk, string pat)
    {
        if(to_chk.size() != pat.size())
        {
            return false;
        }
        /*check the mapping correspondence*/
        map<char, int> chkmap;
        map<char, int> patmap;
        for(auto it : to_chk)
        {
            chkmap[it]++;
        }
        for(auto it : pat)
        {
            patmap[it]++;
        }
        /*check the changing trend*/
        for(int i = 0; i < to_chk.size() - 1; i++)
        {
            if(to_chk[i] == to_chk[i + 1])
            {
                if(pat[i] != pat[i + 1])
                {
                    return false;
                }
            }
            else
            {
                if(pat[i] == pat[i + 1])
                {
                    return false;
                }
                else if(patmap[pat[i]] != chkmap[to_chk[i]] || patmap[pat[i + 1]] != chkmap[to_chk[i + 1]]) /*such as abc and aba should not be the same, if no this part, will get wrong answer*/
                {
                    return false;
                }
            }
        }
        
        
        return true;
    }
};
```

* 分析(正解整體):Time complexity: O(N * K), where N is # of words, and K is the length of word, Space complexity O(N * K), each time for each pattern and word, we use a map to assist.


##[PC. 889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/contest/weekly-contest-98/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) Recursively construct a tree.

* 題意:由先序和後序建立一顆二元樹
* 思路: https://imgur.com/a/s9kTWbG (Picture source credit to: https://www.youtube.com/watch?v=53aOi0Drp9I)
* 分析:Time complexity O(N^2), Space complexity O(N)
*
