# leetcode_OJ WC98 99 100 解題心得
* 暑假最後因實習進度交接，有點累，打了weekly contest結果懶得更新，這次一次更新吧
* Contest time WC98: Aug 19, 2018
* Contest time WC99: Aug 26, 2018
* Contest time WC100: Sep 2, 2018

# WC98 
##[PA. 888. Fair Candy Swap](https://leetcode.com/contest/weekly-contest-98/problems/fair-candy-swap/) 水題
* 題意:兩人各持有數堆糖果，每一堆有n個糖果，問各自交換哪一堆可以讓他們兩個的糖果數量一樣
* 思路:直接做，兩個人一樣取平均，暴力找即可。
* 分析:Time complexity: O(N^2), Space complexity O(N)

```cpp
class Solution 
{
public:
    vector<int> fairCandySwap(vector<int>& A, vector<int>& B) 
    {
        int suma, sumb, flg;
        suma = sumb = 0;
        flg = 0;
        vector<int> res;
        for(int i = 0; i < A.size(); i++)
        {
            suma += A[i];
        }
        for(int i = 0; i < B.size(); i++)
        {
            sumb += B[i];
        }
        int fair = (suma + sumb) / 2;
        for(int i = 0; i < A.size(); i++)
        {
            for(int j = 0; j < B.size(); j++)
            {
                if(suma - A[i] + B[j] == sumb - B[j] + A[i])
                {
                    res.push_back(A[i]);
                    res.push_back(B[j]);
                    flg = 1;
                    break;    
                }
            }
            if(flg)
            {
                break;
            }
        }
        return res;
    }
    bool check(vector<int>& A, vector<int>& B)
    {
        int suma, sumb;
        suma = sumb = 0;
        for(int i = 0; i < A.size(); i++)
        {
            suma += A[i];
        }
        for(int i = 0; i < B.size(); i++)
        {
            sumb += B[i];
        }
        return (suma == sumb) && (suma) && (sumb);//should be more than zero
    }
}; 
```
##[PB. 890. Find and Replace Pattern](https://leetcode.com/contest/weekly-contest-98/problems/find-and-replace-pattern/) string + map
* 題意:找出趨勢一樣的單字，在此趨勢一樣是指英文字出先的『頻率、方式』一致，例如 aabb = ccbb = jjkk , apple = knnrx 等
* WA思路:趨勢一樣代表說，我下一個是不一樣的字母，則你也是;我如果是一樣的則你也要一樣，這樣直接做即可（但是接下來會遇到一個問題，稍後下方『缺失分析』會提及）
```cpp
class Solution 
{
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) 
    {
        vector<string> res;
        for(auto it: words)
        {
            if(check(it, pattern))
            {
                res.push_back(it);
            }
        }
        return res;
    }
    bool check(string to_chk, string pat)
    {
        if(to_chk.size() != pat.size())
        {
            return false;
        }
        for(int i = 0; i < to_chk.size() - 1; i++)
        {
            if(to_chk[i] == to_chk[i + 1]) //趨勢要一致
            {
                if(pat[i] != pat[i + 1])
                {
                    return false;
                }
            }
            else
            {
                if(pat[i] == pat[i + 1]) //趨勢要一致
                {
                    return false;
                }
            }
        }
        return true;
    }
};
```


* 缺失分析:WA的原因在於，這樣會把aba =  xyx = abc 但實際上這題要求連**每一個字母出現頻率也要一樣**，因此最後a b c各自只有一個並不屬於同一類
* 改進思路:多一個map來統計，並且對照組的map內容要和pattern一樣，在英文字母一樣的時候不用管，不一樣時要看各自map內容物是否相等，否則返回false


```cpp
class Solution 
{
public:
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) 
    {
        vector<string> res;
        for(auto it: words)
        {
            if(check(it, pattern))
            {
                res.push_back(it);
            }
        }
        return res;
    }
    bool check(string to_chk, string pat)
    {
        if(to_chk.size() != pat.size())
        {
            return false;
        }
        /*check the mapping correspondence*/
        map<char, int> chkmap;
        map<char, int> patmap;
        for(auto it : to_chk)
        {
            chkmap[it]++;
        }
        for(auto it : pat)
        {
            patmap[it]++;
        }
        /*check the changing trend*/
        for(int i = 0; i < to_chk.size() - 1; i++)
        {
            if(to_chk[i] == to_chk[i + 1])
            {
                if(pat[i] != pat[i + 1])
                {
                    return false;
                }
            }
            else
            {
                if(pat[i] == pat[i + 1])
                {
                    return false;
                }
                else if(patmap[pat[i]] != chkmap[to_chk[i]] || patmap[pat[i + 1]] != chkmap[to_chk[i + 1]]) /*such as abc and aba should not be the same, if no this part, will get wrong answer*/
                {
                    return false;
                }
            }
        }
        
        
        return true;
    }
};
```

* 分析(正解整體):Time complexity: O(N * K), where N is # of words, and K is the length of word, Space complexity O(N * K), each time for each pattern and word, we use a map to assist.


##[PC. 889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/contest/weekly-contest-98/problems/construct-binary-tree-from-preorder-and-postorder-traversal/) Recursively construct a tree.

* 題意:由先序和後序建立一顆二元樹
* 思路: https://imgur.com/a/s9kTWbG (Picture source credit to: https://www.youtube.com/watch?v=53aOi0Drp9I )
    * 首先preorder = {root left right}, post order = {left right root}，利用上方的圖片可以看到，舉例來說 pre = [1,2,4,5,3,6,7]. post = [4,5,2,6,7,3,1]，pre = 1 245 367, post = 452 673 1，pre[1]必為左子樹根，正好對應到post[2] (但不盡然每次都是post[2])，因此可以用code中找出ileft subtree的root位置，最後便能用以下四個(左右子數各自對應之pre post traversal)
 ```cpp
 while(pre[1] != post[left_subtree_root_pos]) //find the equal for the right subtree
 {
     left_subtree_root_pos++;
 } 
 ``` 
        * post traversal of left subtree = post[0:left_subtree_root_pos](雙端皆為封閉區間 []而非())
        * post traversal of right subtree = post[left_subtree_root_pos + 1:-2](雙端皆為封閉區間)
        * pre traversal of left subtree = pre[1:left_subtree_root_pos + 1](雙端皆為封閉區間)
        * pre traversal of right subtree = pre[left_subtree_root_pos + 2:-1](雙端皆為封閉區間)
        * 接著利用root->left = recursively_construct(left_subtree_pre_traverse, left_subtree_post_traverse) 
    * 再利用root->right = recursively_construct(right_subtree_pre_traverse, right_subtree_post_traverse) 
* 分析:Time complexity O(N^2), Space complexity O(N^2) where N is the # of nodes, since each time for every node(N), we have to go through the array of traversed node again(N), which in total is O(N^2)
* 備註:可以用程式碼附的print_subtree_dbg 來看看子樹到底包了哪些東西喔，比較好瞭解，以及一些stdio

```cpp

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) 
    {
        return construct(pre, post);
    }
    TreeNode* construct(vector<int>& pre, vector<int>& post)
    {
        if(pre.size() == 1 && post.size() == 1) // the base case with leaf
        {
            //printf("base case presize %d postsize %d\n", pre.size(), post.size());
            TreeNode* newnode = new TreeNode(pre[0]);    
            return newnode;
        }
        else if(pre.size() == 0 && post.size() == 0) //the null
        {
            return NULL;
        }
        
        vector<int> left_subtree_pre;
        vector<int> left_subtree_pos;
        vector<int> right_subtree_pre;
        vector<int> right_subtree_pos;
        
        int left_subtree_root_pos = 0;
        
        while(pre[1] != post[left_subtree_root_pos]) //find the equal for the right subtree
        {
            left_subtree_root_pos++;
        }
        // printf("\nleft pos %d with root %d\n", left_subtree_root_pos, pre[0]);
        
        for(int i = 0; i <= left_subtree_root_pos; i++)//construct the post traverse of left subtree
        {
            left_subtree_pos.push_back(post[i]);
        }
        for(int i = left_subtree_root_pos + 1; i < post.size() - 1; i++)//construct the post traverse of right subtree
        {
            right_subtree_pos.push_back(post[i]);
        }
        
        for(int i = 1; i <= left_subtree_root_pos + 1; i++)//construct the pre traverse of left subtree
        {
            left_subtree_pre.push_back(pre[i]);
        }
        for(int i = left_subtree_root_pos + 2; i <= post.size() - 1; i++)//construct the pre traverse of right subtree
        {
            right_subtree_pre.push_back(pre[i]);
        }
        
//         print_subtree_dbg("left pos",left_subtree_pos);
//         print_subtree_dbg("right pos",right_subtree_pos);
        
//         print_subtree_dbg("left pre",left_subtree_pre);
//         print_subtree_dbg("right pre",right_subtree_pre);
        
        TreeNode* newnode = new TreeNode(pre[0]); //or post[-1]
        newnode->left = construct(left_subtree_pre, left_subtree_pos);
        newnode->right = construct(right_subtree_pre, right_subtree_pos);
        return newnode;//after construct, return it
    }
    void print_subtree_dbg(string cond, vector<int>& vec)
    {
        cout << cond << " : " ;
        for(int i = 0; i < vec.size(); i++)
        {
            printf("%d ", vec[i]);
        }
        printf("\n");
    }
};
```
