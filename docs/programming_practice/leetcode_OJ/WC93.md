# leetcode_OJ WC93 解題心得
* Contest time: Jul 15, 2018

## PA. [868. Binary Gap](https://leetcode.com/problems/binary-gap/description/) 簡單雙指標
* 思路：直接解即可，用雙指標測量兩個鄰近的1的距離(不一定要相鄰，題目解說有點不清楚)，其中的to_binary是實用的數字轉二進位字串的方法。
* 分析 Time complexity = O(N), Space complexity (with auxilary string structure to store the binary number) = O(N)

```cpp
#define FORI(n) for(int i = 0; i < n; ++ i)
class Solution
{
public:
    int binaryGap(int num)
    {
        string binstr = to_binary(num);
        int maxd = 0;
        for(int i = 0; i < binstr.size() - 1; i++)
        {
            if(binstr[i] == '1')
            {
                for(int j = i + 1; j < binstr.size(); j++)
                {
                    if(binstr[j] == '1')
                    {
                        maxd = max(maxd, j - i);
                        i = j;
                        break;
                    }
                }
            }
        }
        return maxd;
    }
    string to_binary(int num)
    {
        string res;
        while(num)
        {
            if(num & 1)
            {
                res += "1";
            }
            else
            {
                res += "0";
            }
            num /= 2;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};

```

## PB. [869. Reordered Power of 2](https://leetcode.com/problems/reordered-power-of-2/description/) STL活用
* 題意：一個數字的各個位數，經過排列組合(包括不重排)後，其組合是否有可能成為二的次方，例如46重排變成64則符合，1232不管怎排都不行
* 思路：
    * 先將已經是二的倍數，不需重排的直接回傳true。
    * 接著進入while迴圈將每一位數push進入vector中，用algorithm std中的next_permutation排出所有可能，再把它串起來，以.c_str()，加上atoi的方式傳入is_pow2判斷，若有符合則直接回傳true，最後都沒有則回傳false。
    * num & (num - 1) == 0 的話就是二的次方，挺實用的，大家可以透過二進位制想一下為什麼
* 分析 Time complexity = O(logN!??)(**不確定，待確認，希望有先進能賜教，總覺得不太可能到fraction，不然沒有機會ac**), Space complexity (with auxilary string structure to store the number) = O(N)
```cpp
#define pb push_back
class Solution
{
public:
    bool reorderedPowerOf2(int num)
    {
        if(num >= 1 && num <=10)
        {
            if(is_pow2(num))
            {
                return true;
            }
            return false;
        }
        else if(is_pow2(num)) //original order
        {
            return true;
        }
        vector<int> dgt;
        while(num)
        {
            dgt.pb(num % 10);
            num /= 10;
        }
        sort(dgt.begin(), dgt.end());
        int sz = dgt.size(), judge = 0;
        string str;

        do {
            str = "";
            for(int i = 0; i < sz; i++)
            {
                str += (dgt[i] + '0');
            }
            cout << str <<endl;
            judge = atoi(str.c_str());
            if(is_pow2(judge))
            {
                return true;
            }
        }while(next_permutation(dgt.begin(), dgt.end()));
        return false;
    }
    bool is_pow2(int num)
    {
        if((num & (num - 1)) == 0 )
        {
            return true;
        }
        return false;
    }
};

```

## PC.[870. Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle/description/) 貪心算法
* 題解請[見此](https://leetcode.com/problems/advantage-shuffle/discuss/150785/C++-greedy-solution-with-explanation-in-both-Chinese(zh-TW)-and-English)(雙語版本同步刊載於討論區)

## PD. [871. Minimum Number of Refueling Stops](https://leetcode.com/problems/minimum-number-of-refueling-stops/description/) 貌似是動態規劃的題目，尚未作答，等週末來試試
