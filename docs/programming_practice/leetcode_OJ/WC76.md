# leetcode_OJ WC76 解題心得
* Contest time: Mar 18, 2018

## PA. [800. Similar RGB Color](https://leetcode.com/contest/weekly-contest-76/problems/similar-rgb-color/) 麻煩的水題
如題目所述，會需要用到一些位元運算，因此稍嫌麻煩，居然寫了一個多小時才寫出來。
中途還被變更的題說明耍了一道，而且題目說明根本說錯了gg。

cti itc 可以在十六進位和char互相轉換，頗為方便。而stringstream可以把字串在視為輸入處理一次轉成十六盡位在輸入給整數。
```cpp
#define FORI(n) for(int i = 0; i < n; ++ i)
#include <cstdlib>
class Solution
{
public:
    int cti(char c)
    {
        if ( '0'<=c && c<='9' ) return c-'0';
        else return 10+c-'a';
    }
    char itc(int i)
    {
        if (0<=i && i<=9) return '0'+i;
        else return 'a'+i-10;
    }
    string similarRGB(string color)
    {
        int dist = 0, best = 99999999;
        int original = 0;
        color = color.substr(1,6);
        stringstream ss;
        ss<<hex<<color;
        ss>>original;

        int R,G,B,nr,ng,nb,nr1,ng1,nb1;
        string sr,sg,sb;

        R=original & 0xff0000;
        G=original & 0xff00;
        B=original & 0xff;
        R>>=16;
        G>>=8;

        //find smallest R
        for(int i = 0;i < 16;i++)
        {
            nr = i<<4 | i;
            if(abs(nr-R)<best)
            {
                sr="";
                best = abs(nr-R);
                nr = i;
                sr += itc(i);
            }
        }
        //fins smallest G
        best = 99999999;
        for(int i = 0;i < 16;i++)
        {
            ng = i<<4 | i;
            if(abs(ng-G)<best)
            {
                sg="";
                best = abs(ng-G);
                ng = i;
                sg += itc(i);
            }
        }
        //find smallest B
        best = 99999999;
        for(int i = 0;i < 16;i++)
        {
            nb = i<<4 | i;
            if(abs(nb-B)<best)
            {
                sb="";
                best = abs(nb-B);
                nb = i;
                sb += itc(i);
            }
        }

        return "#"+sr+sr+sg+sg+sb+sb;
    }
};

```

## PB.[801. Minimum Swaps To Make Sequences Increasing](https://leetcode.com/contest/weekly-contest-76/problems/minimum-swaps-to-make-sequences-increasing/) 動態規劃

從題目的性質可以看出，每一個階段均要不斷求解這個階段是否要交換（重疊子問題），以符合嚴格遞增的序列。
但是在每一個遞增中，如果每一個元素和它前一個元素都符合嚴格增（最優子結構），那麼整個數列也會是一個嚴格增。
此外，如果本來就符合嚴格增，就不用擔心，或是因為之前的交換(至i-1)而導致第i個需要替換，便需要檢查此次是否要換，也就是向前檢查到前一個。
因此既有符合重疊子問題，又有最優子結構，那就是動態規劃試用的範圍囉
[參考連結:什麼時候用動態規劃演算法](https://hk.saowen.com/a/4828e12cd690ddf64c6469a905194c7672628d731f560080578408609b5cf760)
